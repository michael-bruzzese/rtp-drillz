<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RTP Drillz</title>
  <style>
    :root {
      --bg-dark: #1a1a1a;
      --bg-darker: #0f0f0f;
      --felt: #004d00;
      --text: #e0e0e0;
      --white: #ffffff;
      --orange: #c85f00;
      --orange-hover: #d66d12;
      --danger: #ff3300;
      --panel: #232323;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: Helvetica, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1000px 500px at 50% -10%, #2b2b2b 0%, var(--bg-dark) 45%, var(--bg-darker) 100%);
    }

    .app {
      width: min(1200px, 100%);
      min-height: 100vh;
      margin: 0 auto;
      padding: 18px 20px 22px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .topbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .title {
      margin: 0;
      font-size: clamp(30px, 4.8vw, 52px);
      color: var(--orange);
      letter-spacing: 1px;
      font-weight: 800;
    }

    .timer-wrap {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
      background: #202020;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 10px 12px;
    }

    .timer-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .timer-wrap label {
      font-weight: 700;
      color: var(--text);
      font-size: 14px;
    }

    .mode-wrap {
      display: flex;
      align-items: center;
      gap: 10px;
      background: #202020;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 10px 12px;
    }

    .mode-wrap label {
      font-weight: 700;
      color: var(--text);
      font-size: 14px;
    }

    .timer-pause-btn {
      width: 100%;
      padding: 8px 10px;
      font-size: 12px;
      font-weight: 700;
      border-radius: 8px;
      border: 1px solid #3a3a3a;
      background: #2b2b2b;
      color: var(--white);
      cursor: pointer;
      transition: background 120ms ease;
    }

    .timer-pause-btn:hover {
      background: #3a3a3a;
      transform: none;
    }

    .timer-pause-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    select {
      background: #2a2a2a;
      border: 1px solid #3a3a3a;
      color: var(--white);
      border-radius: 8px;
      padding: 7px 10px;
      font-size: 14px;
      cursor: pointer;
      outline: none;
    }

    select:focus {
      border-color: var(--orange);
      box-shadow: 0 0 0 2px rgba(200, 95, 0, 0.22);
    }

    .table {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 10px;
      border: 2px solid var(--orange);
      border-radius: 16px;
      padding: 24px 14px 14px;
      background:
        radial-gradient(120% 100% at 50% 20%, #0b6b0b 0%, var(--felt) 45%, #003200 100%);
      overflow: hidden;
      transition: background 120ms ease;
    }

    .table.flash {
      background: var(--danger);
    }

    .manual-panel {
      display: none;
      border: 1px solid #343434;
      border-radius: 12px;
      background: #1f1f1f;
      padding: 10px 12px;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .manual-panel.show {
      display: flex;
    }

    .manual-panel-left {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .manual-title {
      font-size: 16px;
      font-weight: 800;
      color: var(--white);
      letter-spacing: 0.2px;
    }

    .manual-summary {
      font-size: 13px;
      color: #d3d3d3;
      opacity: 0.95;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .input-hand-btn {
      padding: 10px 14px;
      font-size: 14px;
      font-weight: 800;
      border: 1px solid #4a4a4a;
      border-radius: 9px;
      background: #2c2c2c;
      color: var(--white);
      cursor: pointer;
    }

    .input-hand-btn:hover {
      background: #3a3a3a;
      transform: none;
    }

    .session-panel {
      display: none;
      border: 1px solid #343434;
      border-radius: 12px;
      background: #1f1f1f;
      padding: 10px 12px;
      gap: 10px;
      flex-direction: column;
    }

    .session-panel.show {
      display: flex;
    }

    .session-top {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .session-top label {
      font-size: 13px;
      font-weight: 700;
      color: #d8d8d8;
    }

    .session-name-input {
      width: min(360px, 100%);
      padding: 7px 10px;
      border-radius: 8px;
      border: 1px solid #3a3a3a;
      background: #272727;
      color: var(--white);
      font-size: 14px;
      outline: none;
    }

    .session-name-input:focus {
      border-color: var(--orange);
      box-shadow: 0 0 0 2px rgba(200, 95, 0, 0.22);
    }

    .session-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .session-actions button {
      font-size: 12px;
      font-weight: 700;
      padding: 8px 11px;
      border-radius: 8px;
      border: 1px solid #4a4a4a;
      background: #2c2c2c;
      color: var(--white);
    }

    .session-actions button:hover {
      background: #3a3a3a;
      transform: none;
    }

    .session-meta {
      font-size: 13px;
      color: #d8d8d8;
      font-weight: 700;
    }

    .session-list {
      display: grid;
      gap: 6px;
      max-height: 180px;
      overflow: auto;
      padding-right: 2px;
    }

    .session-item {
      border: 1px solid #3a3a3a;
      border-radius: 9px;
      background: #232323;
      padding: 7px 8px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      align-items: center;
    }

    .session-item.active {
      border-color: var(--orange);
      background: #2b2016;
    }

    .session-item-label {
      font-size: 12px;
      color: #ececec;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .session-item-actions {
      display: flex;
      gap: 6px;
    }

    .session-item-actions button {
      font-size: 11px;
      padding: 6px 8px;
      border-radius: 7px;
      border: 1px solid #4a4a4a;
      background: #2d2d2d;
      color: var(--white);
    }

    .session-item-actions button:hover {
      background: #3a3a3a;
      transform: none;
    }

    .builder-modal {
      position: fixed;
      inset: 0;
      z-index: 20;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.72);
      padding: 18px;
    }

    .builder-modal.show {
      display: flex;
    }

    .builder-dialog {
      width: min(1120px, 100%);
      max-height: calc(100vh - 36px);
      overflow: auto;
      border: 1px solid #3a3a3a;
      border-radius: 14px;
      background: #191919;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .builder-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .builder-title {
      margin: 0;
      font-size: 19px;
      font-weight: 800;
      color: var(--white);
    }

    .builder-close-btn {
      border: 1px solid #4a4a4a;
      border-radius: 8px;
      padding: 8px 10px;
      background: #282828;
      color: var(--white);
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
    }

    .builder-close-btn:hover {
      background: #363636;
      transform: none;
    }

    .builder-slots {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 8px;
    }

    .builder-slot {
      border: 1px solid #4a4a4a;
      border-radius: 10px;
      background: #232323;
      padding: 6px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
      min-width: 0;
    }

    .builder-slot:hover {
      background: #2b2b2b;
      transform: none;
    }

    .builder-slot.active {
      border-color: var(--orange);
      box-shadow: 0 0 0 1px rgba(200, 95, 0, 0.35) inset;
      background: #2a2118;
    }

    .builder-slot-label {
      font-size: 12px;
      font-weight: 800;
      color: #d7d7d7;
      letter-spacing: 0.2px;
    }

    .builder-slot-card {
      width: 78px;
      height: 112px;
      border-radius: 8px;
      border: 2px dashed #555;
      background: #111;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #9e9e9e;
      font-size: 12px;
      font-weight: 700;
      overflow: hidden;
      text-transform: uppercase;
    }

    .builder-slot-card img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
      background: #fff;
    }

    .builder-slot-card.filled {
      border-style: solid;
      border-color: #be6820;
      background: #fff;
    }

    .builder-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .builder-actions button {
      font-size: 13px;
      font-weight: 700;
      padding: 9px 12px;
      border-radius: 8px;
      border: 1px solid #4b4b4b;
      background: #2c2c2c;
      color: var(--white);
      cursor: pointer;
    }

    .builder-actions button:hover {
      background: #3a3a3a;
      transform: none;
    }

    .builder-actions button.primary {
      background: var(--orange);
      color: #151515;
      border-color: #c06a20;
    }

    .builder-actions button.primary:hover {
      background: var(--orange-hover);
    }

    .builder-grid {
      display: grid;
      grid-template-columns: repeat(13, minmax(0, 1fr));
      gap: 7px;
    }

    .builder-card-btn {
      border: 1px solid #4a4a4a;
      border-radius: 8px;
      padding: 2px;
      background: #242424;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 88px;
      overflow: hidden;
    }

    .builder-card-btn:hover {
      background: #323232;
      transform: none;
    }

    .builder-card-btn img {
      width: 100%;
      max-width: 70px;
      height: auto;
      display: block;
      border-radius: 5px;
      background: #fff;
    }

    .builder-card-fallback {
      width: 100%;
      max-width: 70px;
      height: 96px;
      border-radius: 5px;
      background: #fff;
      color: #111;
      font-size: 20px;
      font-weight: 800;
      display: none;
      align-items: center;
      justify-content: center;
      text-transform: uppercase;
    }

    .builder-card-btn.selected {
      border-color: var(--orange);
      background: #4d2c10;
    }

    .builder-card-btn.active-selected {
      box-shadow: 0 0 0 2px rgba(200, 95, 0, 0.6) inset;
    }

    .countdown {
      position: absolute;
      top: 12px;
      right: 14px;
      color: var(--white);
      font-size: clamp(20px, 3vw, 34px);
      font-weight: 800;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.45);
    }

    .table-config {
      position: absolute;
      z-index: 4;
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.28);
      padding: 8px;
      backdrop-filter: blur(2px);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.28);
    }

    .table-config-left {
      top: 10px;
      left: 12px;
      width: 196px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .table-config-right {
      top: 62px;
      right: 12px;
      width: 172px;
      display: flex;
      flex-direction: column;
      gap: 7px;
    }

    .stack-title {
      color: var(--white);
      text-align: center;
      font-size: 13px;
      font-weight: 800;
      letter-spacing: 0.2px;
      line-height: 1.1;
    }

    .config-row {
      display: grid;
      gap: 6px;
    }

    .config-row.row-three {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .config-row.row-two {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .stack-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }

    .config-btn {
      border: 1px solid #4a4a4a;
      border-radius: 8px;
      padding: 7px 4px;
      font-size: 12px;
      font-weight: 800;
      color: var(--white);
      background: rgba(33, 33, 33, 0.9);
      line-height: 1.1;
      letter-spacing: 0.2px;
      text-align: center;
    }

    .config-btn:hover {
      background: rgba(49, 49, 49, 0.95);
      transform: none;
    }

    .config-btn.active {
      border-color: var(--orange);
      background: #5b2f00;
      color: #fff4e7;
      box-shadow: 0 0 0 1px rgba(200, 95, 0, 0.3) inset;
    }

    .time-overlay {
      position: absolute;
      inset: 0;
      display: none;
      justify-content: center;
      align-items: center;
      font-size: clamp(56px, 11vw, 140px);
      font-weight: 900;
      color: var(--orange);
      background: rgba(0, 0, 0, 0.25);
      text-shadow: 0 0 20px rgba(255, 149, 0, 0.45);
      letter-spacing: 2px;
      z-index: 6;
      pointer-events: none;
    }

    .time-overlay.show {
      display: flex;
      animation: pulse 0.5s infinite alternate;
    }

    @keyframes pulse {
      from { opacity: 0.7; }
      to { opacity: 1; }
    }

    .start-splash {
      margin: 0;
      font-size: clamp(56px, 9vw, 128px);
      color: var(--orange);
      font-weight: 900;
      letter-spacing: 2px;
      user-select: none;
      pointer-events: none;
      text-align: center;
      transform: translateY(10px);
    }

    .board-title {
      margin: 8px 0 0;
      font-size: clamp(24px, 3.5vw, 38px);
      color: var(--white);
      font-weight: 800;
      letter-spacing: 0.5px;
    }

    .status {
      min-height: 24px;
      margin: 8px 0 0;
      font-size: clamp(16px, 2.2vw, 22px);
      color: var(--text);
      text-align: center;
      font-weight: 500;
      text-shadow: 0 1px 6px rgba(0, 0, 0, 0.25);
    }

    .cards {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      min-height: 162px;
      padding: 4px 6px;
    }

    .hero-wrap {
      border-radius: 14px;
      background: linear-gradient(180deg, #242424 0%, #181818 100%);
      border: 1px solid #333;
      padding: 14px 16px 16px;
    }

    .hero-title {
      margin: 2px 0 10px;
      text-align: center;
      color: var(--white);
      font-size: clamp(22px, 3.2vw, 34px);
      font-weight: 800;
    }

    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
      min-height: 60px;
    }

    button {
      border: 0;
      border-radius: 10px;
      padding: 12px 18px;
      font-size: 15px;
      font-weight: 700;
      color: var(--white);
      background: #2b2b2b;
      cursor: pointer;
      transition: background 120ms ease, transform 120ms ease;
    }

    button:hover {
      background: #3a3a3a;
      transform: translateY(-1px);
    }

    button.primary {
      color: #151515;
      background: var(--orange);
      font-size: 18px;
      padding: 14px 24px;
    }

    button.primary:hover {
      background: var(--orange-hover);
    }

    .card-shell {
      background: var(--orange);
      border-radius: 8px;
      padding: 2px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
    }

    .card {
      display: block;
      height: 145px;
      width: auto;
      background: #fff;
      border-radius: 6px;
    }

    .card-fallback {
      display: none;
      width: 102px;
      height: 145px;
      border-radius: 6px;
      background: #fff;
      color: #111;
      font-weight: 800;
      font-size: 28px;
      align-items: center;
      justify-content: center;
      text-transform: uppercase;
      user-select: none;
    }

    .empty-board {
      font-size: 16px;
      opacity: 0.95;
    }

    @media (max-width: 900px) {
      .app {
        padding: 14px 12px 16px;
      }

      .manual-panel {
        flex-direction: column;
        align-items: flex-start;
      }

      .session-top {
        align-items: flex-start;
        flex-direction: column;
      }

      .session-name-input {
        width: 100%;
      }

      .manual-summary {
        white-space: normal;
      }

      .builder-slots {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .builder-grid {
        grid-template-columns: repeat(6, minmax(0, 1fr));
      }

      .table {
        padding: 20px 10px 12px;
      }

      .table-config {
        position: static;
        width: 100%;
        max-width: 360px;
      }

      .table-config-left,
      .table-config-right {
        width: 100%;
      }

      .table-config-right {
        margin-top: 6px;
      }

      .card {
        height: 126px;
      }

      .card-fallback {
        height: 126px;
        width: 89px;
        font-size: 24px;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <header class="topbar">
      <h1 class="title">RTP Drillz</h1>
      <div class="timer-wrap">
        <div class="timer-row">
          <label for="timerSelect">Timer / street</label>
          <select id="timerSelect">
            <option>None</option>
            <option>10s</option>
            <option>15s</option>
            <option>30s</option>
            <option>45s</option>
            <option>60s</option>
            <option>90s</option>
          </select>
        </div>
        <button id="timerPauseBtn" class="timer-pause-btn" type="button" disabled>Pause Timer</button>
      </div>
      <div class="mode-wrap">
        <label for="modeSelect">Mode</label>
        <select id="modeSelect">
          <option value="live">Live Drill</option>
          <option value="replay">Hand Replay</option>
        </select>
      </div>
    </header>

    <section id="manualPanel" class="manual-panel">
      <div class="manual-panel-left">
        <div class="manual-title">Hand Replay Setup</div>
        <div id="manualSummary" class="manual-summary">No hand loaded yet.</div>
      </div>
      <button id="inputHandBtn" class="input-hand-btn" type="button">Input Hand</button>
    </section>

    <section id="sessionPanel" class="session-panel">
      <div class="session-top">
        <label for="sessionNameInput">Session Name</label>
        <input
          id="sessionNameInput"
          class="session-name-input"
          type="text"
          maxlength="40"
          placeholder="e.g. BTN vs BB SRP review"
        />
      </div>
      <div class="session-actions">
        <button id="addSessionHandBtn" type="button">Add Loaded Hand</button>
        <button id="startSessionBtn" type="button">Start Session</button>
        <button id="clearSessionBtn" type="button">Clear Session</button>
        <button id="exportSessionBtn" type="button">Export Session</button>
        <button id="importSessionBtn" type="button">Import Session</button>
        <input id="importSessionInput" type="file" accept=".json,application/json" style="display:none" />
      </div>
      <div id="sessionMeta" class="session-meta">0 / 10 hands queued</div>
      <div id="sessionList" class="session-list"></div>
    </section>

    <section id="table" class="table">
      <div id="countdown" class="countdown">Time left: --:--</div>
      <div id="timeOverlay" class="time-overlay">TIME!</div>
      <div class="table-config table-config-left">
        <div class="config-row row-three">
          <button class="config-btn" type="button" data-config-group="spotType" data-config-value="SRP">SRP</button>
          <button class="config-btn" type="button" data-config-group="spotType" data-config-value="3BP">3BP</button>
          <button class="config-btn" type="button" data-config-group="spotType" data-config-value="4BP">4BP</button>
        </div>
        <div class="config-row row-two">
          <button class="config-btn" type="button" data-config-group="position" data-config-value="IP">IP</button>
          <button class="config-btn" type="button" data-config-group="position" data-config-value="OOP">OOP</button>
        </div>
        <div class="config-row row-two">
          <button class="config-btn" type="button" data-config-group="role" data-config-value="PFR">PFR</button>
          <button class="config-btn" type="button" data-config-group="role" data-config-value="PFC">PFC</button>
        </div>
      </div>
      <div class="table-config table-config-right">
        <div class="stack-title">Effective Stacks</div>
        <div class="stack-grid">
          <button class="config-btn" type="button" data-config-group="stacks" data-config-value="50BB">50BB</button>
          <button class="config-btn" type="button" data-config-group="stacks" data-config-value="100BB">100BB</button>
          <button class="config-btn" type="button" data-config-group="stacks" data-config-value="150BB">150BB</button>
          <button class="config-btn" type="button" data-config-group="stacks" data-config-value="200BB">200BB</button>
          <button class="config-btn" type="button" data-config-group="stacks" data-config-value="300BB">300BB</button>
          <button class="config-btn" type="button" data-config-group="stacks" data-config-value="500BB+">500BB+</button>
        </div>
      </div>
      <h2 id="startSplash" class="start-splash">RTP Drillz</h2>

      <h3 class="board-title">Board</h3>
      <div id="boardCards" class="cards"></div>
      <p id="status" class="status">&nbsp;</p>
    </section>

    <section class="hero-wrap">
      <h3 class="hero-title">Hero Hand</h3>
      <div id="handCards" class="cards"></div>
    </section>

    <nav id="controls" class="controls"></nav>
  </main>

  <div id="handBuilderModal" class="builder-modal" aria-hidden="true">
    <div class="builder-dialog">
      <div class="builder-top">
        <h3 class="builder-title">Input Hand</h3>
        <button id="builderCloseBtn" class="builder-close-btn" type="button">Close</button>
      </div>

      <div id="builderSlots" class="builder-slots">
        <button type="button" class="builder-slot" data-builder-slot="hand1">
          <span class="builder-slot-label">Hero 1</span>
          <div class="builder-slot-card"></div>
        </button>
        <button type="button" class="builder-slot" data-builder-slot="hand2">
          <span class="builder-slot-label">Hero 2</span>
          <div class="builder-slot-card"></div>
        </button>
        <button type="button" class="builder-slot" data-builder-slot="flop1">
          <span class="builder-slot-label">Flop 1</span>
          <div class="builder-slot-card"></div>
        </button>
        <button type="button" class="builder-slot" data-builder-slot="flop2">
          <span class="builder-slot-label">Flop 2</span>
          <div class="builder-slot-card"></div>
        </button>
        <button type="button" class="builder-slot" data-builder-slot="flop3">
          <span class="builder-slot-label">Flop 3</span>
          <div class="builder-slot-card"></div>
        </button>
        <button type="button" class="builder-slot" data-builder-slot="turn">
          <span class="builder-slot-label">Turn</span>
          <div class="builder-slot-card"></div>
        </button>
        <button type="button" class="builder-slot" data-builder-slot="river">
          <span class="builder-slot-label">River</span>
          <div class="builder-slot-card"></div>
        </button>
      </div>

      <div class="builder-actions">
        <button id="builderClearSlotBtn" type="button">Clear Slot</button>
        <button id="builderClearAllBtn" type="button">Clear All</button>
        <button id="builderAutoFillBtn" type="button">Auto-Fill Missing</button>
        <button id="builderApplyBtn" type="button" class="primary">Apply</button>
      </div>

      <div id="builderDeckGrid" class="builder-grid"></div>
    </div>
  </div>

  <script>
    "use strict";

    const RANKS = "23456789TJQKA".split("");
    const SUITS = "shdc".split("");
    const TIMER_KEY = "rtpDrillzTimerChoice";
    const MODE_KEY = "rtpDrillzModeChoice";
    const TIMER_MAP = {
      None: 0,
      "10s": 10,
      "15s": 15,
      "30s": 30,
      "45s": 45,
      "60s": 60,
      "90s": 90
    };
    const MAX_SESSION_HANDS = 10;

    const CARD_PREFIXES = [
      "",
      "cards/",
      "png-card-1.3/",
      "PNG-card-1.3/",
      "PNG-cards-1.3/",
      "deck/",
      "images/",
      "img/"
    ];
    const RANK_WORD = {
      A: "ace",
      K: "king",
      Q: "queen",
      J: "jack",
      T: "10",
      "9": "9",
      "8": "8",
      "7": "7",
      "6": "6",
      "5": "5",
      "4": "4",
      "3": "3",
      "2": "2"
    };
    const RANK_NAME = {
      A: "Ace",
      K: "King",
      Q: "Queen",
      J: "Jack",
      T: "Ten",
      "9": "Nine",
      "8": "Eight",
      "7": "Seven",
      "6": "Six",
      "5": "Five",
      "4": "Four",
      "3": "Three",
      "2": "Two"
    };
    const SUIT_WORD = {
      s: "spades",
      h: "hearts",
      d: "diamonds",
      c: "clubs"
    };
    const SUIT_NAME = {
      s: "Spades",
      h: "Hearts",
      d: "Diamonds",
      c: "Clubs"
    };
    const EMBEDDED_CARDS =
      window.__RTP_EMBEDDED_CARDS__ && typeof window.__RTP_EMBEDDED_CARDS__ === "object"
        ? window.__RTP_EMBEDDED_CARDS__
        : {};
    const GENERATED_BACK_DATA_URI = buildGeneratedBackDataUri();

    const state = {
      stage: "start",
      mode: "live",
      hand: [],
      board: [],
      deck: [],
      manual: {
        hand1: "",
        hand2: "",
        flop1: "",
        flop2: "",
        flop3: "",
        turn: "",
        river: ""
      },
      session: {
        name: "",
        hands: [],
        active: false,
        index: 0
      },
      config: {
        spotType: "",
        position: "",
        role: "",
        stacks: ""
      },
      timerChoice: "None",
      timeLeft: 0,
      timerId: null,
      timerPaused: false,
      flashId: null
    };
    let audioContext = null;
    const handBuilderState = {
      open: false,
      activeField: "hand1",
      draft: {},
      deckButtons: {}
    };

    const els = {
      timerSelect: document.getElementById("timerSelect"),
      timerPauseBtn: document.getElementById("timerPauseBtn"),
      modeSelect: document.getElementById("modeSelect"),
      manualPanel: document.getElementById("manualPanel"),
      sessionPanel: document.getElementById("sessionPanel"),
      inputHandBtn: document.getElementById("inputHandBtn"),
      manualSummary: document.getElementById("manualSummary"),
      sessionNameInput: document.getElementById("sessionNameInput"),
      addSessionHandBtn: document.getElementById("addSessionHandBtn"),
      startSessionBtn: document.getElementById("startSessionBtn"),
      clearSessionBtn: document.getElementById("clearSessionBtn"),
      exportSessionBtn: document.getElementById("exportSessionBtn"),
      importSessionBtn: document.getElementById("importSessionBtn"),
      importSessionInput: document.getElementById("importSessionInput"),
      sessionMeta: document.getElementById("sessionMeta"),
      sessionList: document.getElementById("sessionList"),
      handBuilderModal: document.getElementById("handBuilderModal"),
      builderSlots: Array.from(document.querySelectorAll("[data-builder-slot]")),
      builderDeckGrid: document.getElementById("builderDeckGrid"),
      builderCloseBtn: document.getElementById("builderCloseBtn"),
      builderClearSlotBtn: document.getElementById("builderClearSlotBtn"),
      builderClearAllBtn: document.getElementById("builderClearAllBtn"),
      builderAutoFillBtn: document.getElementById("builderAutoFillBtn"),
      builderApplyBtn: document.getElementById("builderApplyBtn"),
      table: document.getElementById("table"),
      countdown: document.getElementById("countdown"),
      timeOverlay: document.getElementById("timeOverlay"),
      startSplash: document.getElementById("startSplash"),
      boardCards: document.getElementById("boardCards"),
      handCards: document.getElementById("handCards"),
      controls: document.getElementById("controls"),
      status: document.getElementById("status"),
      configButtons: Array.from(document.querySelectorAll("[data-config-group]"))
    };

    function init() {
      const savedTimer = localStorage.getItem(TIMER_KEY);
      if (savedTimer && Object.prototype.hasOwnProperty.call(TIMER_MAP, savedTimer)) {
        state.timerChoice = savedTimer;
      }
      const savedMode = localStorage.getItem(MODE_KEY);
      if (savedMode === "live" || savedMode === "replay") {
        state.mode = savedMode;
      }
      els.timerSelect.value = state.timerChoice;
      els.modeSelect.value = state.mode;
      els.sessionNameInput.value = state.session.name;
      updateManualPanelVisibility();

      els.timerSelect.addEventListener("change", () => {
        ensureAudioContext();
        state.timerChoice = els.timerSelect.value;
        localStorage.setItem(TIMER_KEY, state.timerChoice);

        if (["flop", "turn", "river"].includes(state.stage)) {
          startTimerForStreet();
        } else if (state.timerChoice === "None") {
          setCountdownIdle();
        }
        updateTimerPauseButton();
      });

      els.timerPauseBtn.addEventListener("click", toggleTimerPause);
      els.modeSelect.addEventListener("change", () => {
        state.mode = els.modeSelect.value === "replay" ? "replay" : "live";
        localStorage.setItem(MODE_KEY, state.mode);
        updateManualPanelVisibility();
        refreshScene();
      });
      els.sessionNameInput.addEventListener("input", () => {
        state.session.name = (els.sessionNameInput.value || "").trim();
      });
      els.addSessionHandBtn.addEventListener("click", addLoadedHandToSession);
      els.startSessionBtn.addEventListener("click", startSessionQueue);
      els.clearSessionBtn.addEventListener("click", clearSessionQueue);
      els.exportSessionBtn.addEventListener("click", exportSessionQueue);
      els.importSessionBtn.addEventListener("click", () => els.importSessionInput.click());
      els.importSessionInput.addEventListener("change", importSessionQueueFile);
      els.inputHandBtn.addEventListener("click", openHandBuilder);

      initManualBuilder();
      bindConfigControls();
      renderConfigSelections();
      renderSessionQueue();
      refreshScene();
    }

    function updateManualPanelVisibility() {
      const show = state.mode === "replay";
      els.manualPanel.classList.toggle("show", show);
      els.sessionPanel.classList.toggle("show", show);
      if (!show && handBuilderState.open) {
        closeHandBuilder(false);
      }
      if (!show) {
        state.session.active = false;
        state.session.index = 0;
      }
      renderSessionQueue();
    }

    function manualFieldOrder() {
      return ["hand1", "hand2", "flop1", "flop2", "flop3", "turn", "river"];
    }

    function cloneManualValues(source) {
      const out = {};
      manualFieldOrder().forEach((field) => {
        out[field] = source[field] || "";
      });
      return out;
    }

    function firstEmptyManualField(values) {
      return manualFieldOrder().find((field) => !values[field]) || "hand1";
    }

    function manualCardDisplay(card) {
      return card ? formatCard(card) : "--";
    }

    function cardPrettyName(code) {
      if (!code || code.length < 2) return "that card";
      const rank = code[0].toUpperCase();
      const suit = code[1].toLowerCase();
      return `${RANK_NAME[rank] || rank} of ${SUIT_NAME[suit] || suit}`;
    }

    function showDuplicateCardWarning(cardCode) {
      const cardName = cardPrettyName(cardCode);
      window.alert(
        `Deck should not have two ${cardName} unless you're playing against magicians... and you should not play against magicians.`
      );
    }

    function renderManualSummary() {
      const hero = `${manualCardDisplay(state.manual.hand1)} ${manualCardDisplay(state.manual.hand2)}`;
      const flop = `${manualCardDisplay(state.manual.flop1)} ${manualCardDisplay(state.manual.flop2)} ${manualCardDisplay(state.manual.flop3)}`;
      const turn = manualCardDisplay(state.manual.turn);
      const river = manualCardDisplay(state.manual.river);
      els.manualSummary.textContent = `Hero: ${hero} | Flop: ${flop} | Turn: ${turn} | River: ${river}`;
    }

    function summarizeManualLine(manual) {
      const hero = `${manualCardDisplay(manual.hand1)} ${manualCardDisplay(manual.hand2)}`;
      const flop = `${manualCardDisplay(manual.flop1)} ${manualCardDisplay(manual.flop2)} ${manualCardDisplay(manual.flop3)}`;
      const turn = manualCardDisplay(manual.turn);
      const river = manualCardDisplay(manual.river);
      return `Hero ${hero} | Flop ${flop} | Turn ${turn} | River ${river}`;
    }

    function hasHeroCards(manual) {
      return Boolean(manual.hand1 && manual.hand2);
    }

    function loadSessionHandAt(index, resetStreet) {
      if (index < 0 || index >= state.session.hands.length) return;
      state.session.index = index;
      state.manual = cloneManualValues(state.session.hands[index]);
      renderManualSummary();
      if (resetStreet) {
        stopTimer(true);
        hideTimeOverlay();
        stopTableFlash();
        state.hand = [];
        state.board = [];
        state.deck = [];
        state.stage = "start";
        refreshScene();
      }
      renderSessionQueue();
    }

    function renderSessionQueue() {
      const count = state.session.hands.length;
      const progress = state.session.active
        ? ` | Running ${Math.min(state.session.index + 1, Math.max(count, 1))}/${Math.max(count, 1)}`
        : "";
      els.sessionMeta.textContent = `${count} / ${MAX_SESSION_HANDS} hands queued${progress}`;

      els.addSessionHandBtn.disabled = count >= MAX_SESSION_HANDS;
      els.startSessionBtn.disabled = count === 0;
      els.clearSessionBtn.disabled = count === 0;
      els.exportSessionBtn.disabled = count === 0;

      els.sessionList.innerHTML = "";
      if (!count) {
        const empty = document.createElement("div");
        empty.className = "session-item-label";
        empty.textContent = "No hands in queue yet.";
        els.sessionList.appendChild(empty);
        return;
      }

      state.session.hands.forEach((hand, index) => {
        const row = document.createElement("div");
        row.className = "session-item";
        if (state.session.active && index === state.session.index) {
          row.classList.add("active");
        }

        const label = document.createElement("div");
        label.className = "session-item-label";
        label.textContent = `${index + 1}. ${summarizeManualLine(hand)}`;

        const actions = document.createElement("div");
        actions.className = "session-item-actions";

        const loadBtn = document.createElement("button");
        loadBtn.type = "button";
        loadBtn.textContent = "Load";
        loadBtn.addEventListener("click", () => {
          state.session.active = false;
          loadSessionHandAt(index, true);
        });

        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.textContent = "Remove";
        removeBtn.addEventListener("click", () => {
          state.session.hands.splice(index, 1);
          if (!state.session.hands.length) {
            state.session.active = false;
            state.session.index = 0;
          } else if (state.session.index >= state.session.hands.length) {
            state.session.index = state.session.hands.length - 1;
          }
          if (state.session.active && state.session.hands.length) {
            state.manual = cloneManualValues(state.session.hands[state.session.index]);
            renderManualSummary();
          }
          renderSessionQueue();
        });

        actions.appendChild(loadBtn);
        actions.appendChild(removeBtn);
        row.appendChild(label);
        row.appendChild(actions);
        els.sessionList.appendChild(row);
      });
    }

    function addLoadedHandToSession() {
      if (!hasHeroCards(state.manual)) {
        window.alert("Load at least two hero cards before adding this hand to the session.");
        return;
      }
      if (state.session.hands.length >= MAX_SESSION_HANDS) {
        window.alert(`Session queue is capped at ${MAX_SESSION_HANDS} hands.`);
        return;
      }

      state.session.hands.push(cloneManualValues(state.manual));
      renderSessionQueue();
    }

    function startSessionQueue() {
      if (!state.session.hands.length) {
        window.alert("Add at least one hand to the session queue first.");
        return;
      }
      state.session.active = true;
      loadSessionHandAt(0, true);
    }

    function clearSessionQueue() {
      state.session.hands = [];
      state.session.active = false;
      state.session.index = 0;
      renderSessionQueue();
    }

    function safeSessionFileName(name) {
      const base = (name || "rtp-session")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/(^-|-$)/g, "")
        .slice(0, 40);
      return base || "rtp-session";
    }

    function exportSessionQueue() {
      if (!state.session.hands.length) return;
      const payload = {
        version: 1,
        session_name: state.session.name || "RTP Session",
        created_at: new Date().toISOString(),
        hand_count: state.session.hands.length,
        hands: state.session.hands.map((hand) => cloneManualValues(hand))
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${safeSessionFileName(state.session.name)}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function parseImportedSessionHand(raw) {
      const parsed = {};
      const used = new Set();
      manualFieldOrder().forEach((field) => {
        const value = typeof raw[field] === "string" ? raw[field].trim() : "";
        if (!value) {
          parsed[field] = "";
          return;
        }
        const normalized = formatCard(value);
        if (!/^[2-9TJQKA][shdc]$/.test(normalized)) {
          throw new Error("Invalid card code in imported session.");
        }
        if (used.has(normalized)) {
          throw new Error("Duplicate card found in imported hand.");
        }
        used.add(normalized);
        parsed[field] = normalized;
      });
      return parsed;
    }

    async function importSessionQueueFile(event) {
      const file = event.target.files && event.target.files[0];
      els.importSessionInput.value = "";
      if (!file) return;

      try {
        const text = await file.text();
        const parsed = JSON.parse(text);
        if (!parsed || !Array.isArray(parsed.hands)) {
          throw new Error("Session file missing hands array.");
        }

        const imported = [];
        for (const raw of parsed.hands) {
          imported.push(parseImportedSessionHand(raw || {}));
          if (imported.length >= MAX_SESSION_HANDS) break;
        }

        state.session.name =
          typeof parsed.session_name === "string" ? parsed.session_name.trim().slice(0, 40) : "";
        els.sessionNameInput.value = state.session.name;
        state.session.hands = imported;
        state.session.active = false;
        state.session.index = 0;
        if (state.session.hands.length) {
          state.manual = cloneManualValues(state.session.hands[0]);
          renderManualSummary();
        }
        renderSessionQueue();
      } catch (_err) {
        window.alert("Could not import that session file. Please check the JSON format.");
      }
    }

    function createBuilderDeckButton(card) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "builder-card-btn";
      btn.dataset.card = card;
      btn.title = cardPrettyName(card);

      const img = document.createElement("img");
      img.alt = `Card ${formatCard(card)}`;

      const fallback = document.createElement("div");
      fallback.className = "builder-card-fallback";
      fallback.textContent = formatCard(card);

      btn.appendChild(img);
      btn.appendChild(fallback);

      const key = formatCard(card);
      if (EMBEDDED_CARDS[key]) {
        img.src = EMBEDDED_CARDS[key];
        fallback.style.display = "none";
      } else {
        attachImageWithFallback(img, fallback, cardImageCandidates(card));
      }

      btn.addEventListener("click", () => {
        pickBuilderCard(card);
      });

      return btn;
    }

    function createBuilderSlotFace(card, slotBody) {
      slotBody.innerHTML = "";
      slotBody.classList.toggle("filled", Boolean(card));
      if (!card) {
        slotBody.textContent = "--";
        return;
      }

      const img = document.createElement("img");
      img.alt = `Card ${formatCard(card)}`;

      const fallback = document.createElement("div");
      fallback.className = "builder-card-fallback";
      fallback.textContent = formatCard(card);

      slotBody.appendChild(img);
      slotBody.appendChild(fallback);

      const key = formatCard(card);
      if (EMBEDDED_CARDS[key]) {
        img.src = EMBEDDED_CARDS[key];
        fallback.style.display = "none";
      } else {
        attachImageWithFallback(img, fallback, cardImageCandidates(card));
      }
    }

    function renderBuilderDeckSelection() {
      const selectedCards = new Set(
        manualFieldOrder().map((field) => handBuilderState.draft[field]).filter(Boolean)
      );
      const activeCard = handBuilderState.draft[handBuilderState.activeField];
      buildFullDeck().forEach((card) => {
        const btn = handBuilderState.deckButtons[card];
        if (!btn) return;
        btn.classList.toggle("selected", selectedCards.has(card));
        btn.classList.toggle("active-selected", Boolean(activeCard && activeCard === card));
      });
    }

    function renderBuilderSlots() {
      els.builderSlots.forEach((slotBtn) => {
        const field = slotBtn.dataset.builderSlot;
        if (!field) return;
        slotBtn.classList.toggle("active", field === handBuilderState.activeField);
        const slotBody = slotBtn.querySelector(".builder-slot-card");
        createBuilderSlotFace(handBuilderState.draft[field] || "", slotBody);
      });
      renderBuilderDeckSelection();
    }

    function setBuilderActiveField(field) {
      if (!manualFieldOrder().includes(field)) return;
      handBuilderState.activeField = field;
      renderBuilderSlots();
    }

    function nextBuilderField(currentField) {
      const order = manualFieldOrder();
      const idx = order.indexOf(currentField);
      if (idx < 0 || idx >= order.length - 1) return currentField;
      return order[idx + 1];
    }

    function pickBuilderCard(card) {
      const activeField = handBuilderState.activeField;
      if (!activeField) return;

      const duplicateField = manualFieldOrder().find(
        (field) => field !== activeField && handBuilderState.draft[field] === card
      );
      if (duplicateField) {
        handBuilderState.draft[duplicateField] = "";
      }

      handBuilderState.draft[activeField] = card;
      handBuilderState.activeField = nextBuilderField(activeField);
      renderBuilderSlots();
    }

    function clearBuilderActiveSlot() {
      const activeField = handBuilderState.activeField;
      if (!activeField) return;
      handBuilderState.draft[activeField] = "";
      renderBuilderSlots();
    }

    function clearBuilderAllSlots() {
      manualFieldOrder().forEach((field) => {
        handBuilderState.draft[field] = "";
      });
      handBuilderState.activeField = "hand1";
      renderBuilderSlots();
    }

    function autoFillBuilderMissing() {
      const used = new Set(
        manualFieldOrder().map((field) => handBuilderState.draft[field]).filter(Boolean)
      );
      manualFieldOrder().forEach((field) => {
        if (handBuilderState.draft[field]) return;
        const picked = randomAvailableCard(used);
        if (!picked) return;
        handBuilderState.draft[field] = picked;
        used.add(picked);
      });
      renderBuilderSlots();
    }

    function openHandBuilder() {
      handBuilderState.draft = cloneManualValues(state.manual);
      handBuilderState.activeField = firstEmptyManualField(handBuilderState.draft);
      handBuilderState.open = true;
      els.handBuilderModal.classList.add("show");
      els.handBuilderModal.setAttribute("aria-hidden", "false");
      renderBuilderSlots();
    }

    function closeHandBuilder(applyChanges) {
      if (!handBuilderState.open) return;
      if (applyChanges) {
        state.manual = cloneManualValues(handBuilderState.draft);
        renderManualSummary();
      }
      handBuilderState.open = false;
      els.handBuilderModal.classList.remove("show");
      els.handBuilderModal.setAttribute("aria-hidden", "true");
    }

    function initManualBuilder() {
      handBuilderState.draft = cloneManualValues(state.manual);
      handBuilderState.activeField = "hand1";

      buildFullDeck().forEach((card) => {
        const btn = createBuilderDeckButton(card);
        handBuilderState.deckButtons[card] = btn;
        els.builderDeckGrid.appendChild(btn);
      });

      els.builderSlots.forEach((slotBtn) => {
        const field = slotBtn.dataset.builderSlot;
        if (!field) return;
        slotBtn.addEventListener("click", () => setBuilderActiveField(field));
      });

      els.builderCloseBtn.addEventListener("click", () => closeHandBuilder(false));
      els.builderApplyBtn.addEventListener("click", () => closeHandBuilder(true));
      els.builderClearSlotBtn.addEventListener("click", clearBuilderActiveSlot);
      els.builderClearAllBtn.addEventListener("click", clearBuilderAllSlots);
      els.builderAutoFillBtn.addEventListener("click", autoFillBuilderMissing);
      els.handBuilderModal.addEventListener("click", (event) => {
        if (event.target === els.handBuilderModal) {
          closeHandBuilder(false);
        }
      });

      renderManualSummary();
    }

    function bindConfigControls() {
      els.configButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const group = btn.dataset.configGroup;
          const value = btn.dataset.configValue;
          if (!group || !value) return;
          state.config[group] = value;
          renderConfigSelections();
        });
      });
    }

    function renderConfigSelections() {
      els.configButtons.forEach((btn) => {
        const group = btn.dataset.configGroup;
        const value = btn.dataset.configValue;
        const selected = Boolean(group && value && state.config[group] === value);
        btn.classList.toggle("active", selected);
        btn.setAttribute("aria-pressed", selected ? "true" : "false");
      });

      const labels = [state.config.spotType, state.config.position, state.config.role].filter(Boolean);
      els.status.textContent = labels.length ? labels.join(" | ") : "\u00a0";
    }

    function buildFullDeck() {
      const deck = [];
      for (const rank of RANKS) {
        for (const suit of SUITS) {
          deck.push(`${rank}${suit}`);
        }
      }
      return deck;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function resetDeck(excluded = []) {
      const blocked = new Set(excluded);
      state.deck = buildFullDeck().filter((c) => !blocked.has(c));
      shuffle(state.deck);
    }

    function dealCard() {
      if (!state.deck.length) {
        resetDeck([...state.hand, ...state.board]);
      }
      return state.deck.pop();
    }

    function rankValue(rank) {
      return RANKS.indexOf(rank.toUpperCase()) + 2;
    }

    function isPlayableHand(c1, c2) {
      const r1 = c1[0];
      const s1 = c1[1];
      const r2 = c2[0];
      const s2 = c2[1];
      const v1 = rankValue(r1);
      const v2 = rankValue(r2);

      if (v1 === v2) {
        return true;
      }

      if (s1 === s2) {
        return true;
      }

      const high = Math.max(v1, v2);
      const low = Math.min(v1, v2);
      const gap = high - low - 1;

      if (high >= 12 && low >= 10) return true;
      if (high === 14 && low >= 7) return true;
      if (high === 13 && low >= 9) return true;
      if (high === 12 && low >= 9) return true;
      if (high === 11 && low >= 9) return true;
      if (high >= 10 && low >= 7 && gap <= 2) return true;
      if ((high === 9 && low === 8) || (high === 8 && low === 7)) return true;

      return false;
    }

    function generatePlayableHand() {
      const deck = buildFullDeck();
      while (true) {
        const idx1 = Math.floor(Math.random() * deck.length);
        let idx2 = Math.floor(Math.random() * deck.length);
        while (idx2 === idx1) {
          idx2 = Math.floor(Math.random() * deck.length);
        }

        const c1 = deck[idx1];
        const c2 = deck[idx2];
        if (isPlayableHand(c1, c2)) {
          return [c1, c2].sort((a, b) => rankValue(b[0]) - rankValue(a[0]));
        }
      }
    }

    function randomAvailableCard(excludedSet) {
      const available = buildFullDeck().filter((card) => !excludedSet.has(card));
      if (!available.length) return "";
      const index = Math.floor(Math.random() * available.length);
      return available[index];
    }

    function resolveReplayCards(currentValues, fieldNames, excludedCards, streetLabel) {
      const resolved = currentValues.slice();
      const used = new Set(excludedCards);
      let changed = false;

      for (let i = 0; i < resolved.length; i += 1) {
        const card = resolved[i];
        if (!card) continue;
        if (used.has(card)) {
          resolved[i] = "";
          state.manual[fieldNames[i]] = "";
          changed = true;
          showDuplicateCardWarning(card);
          continue;
        }
        used.add(card);
      }

      const missing = [];
      for (let i = 0; i < resolved.length; i += 1) {
        if (!resolved[i]) missing.push(i);
      }

      if (missing.length) {
        const plural = missing.length > 1 ? "cards" : "card";
        const allowRandom = window.confirm(
          `${streetLabel} is missing ${missing.length} ${plural}. Click OK to add random ${plural}, or Cancel to edit.`
        );
        if (!allowRandom) {
          if (changed) renderManualSummary();
          return null;
        }

        missing.forEach((idx) => {
          const picked = randomAvailableCard(used);
          if (!picked) return;
          resolved[idx] = picked;
          used.add(picked);
          state.manual[fieldNames[idx]] = picked;
          changed = true;
        });
      }

      if (changed) renderManualSummary();
      return resolved;
    }

    function dealHand() {
      stopTimer(true);
      hideTimeOverlay();
      stopTableFlash();

      if (state.mode === "replay" && state.session.active) {
        if (!state.session.hands.length) {
          state.session.active = false;
          state.session.index = 0;
        } else if (state.stage === "done") {
          if (state.session.index < state.session.hands.length - 1) {
            loadSessionHandAt(state.session.index + 1, false);
          } else {
            state.session.active = false;
            window.alert("Session complete. Nice work.");
          }
        } else {
          loadSessionHandAt(state.session.index, false);
        }
      }

      if (state.mode === "replay") {
        const replayHand = resolveReplayCards(
          [state.manual.hand1, state.manual.hand2],
          ["hand1", "hand2"],
          [],
          "Hero hand"
        );
        if (!replayHand) return;
        state.hand = replayHand;
      } else {
        state.hand = generatePlayableHand();
      }
      state.board = [];
      state.stage = "hand";
      renderSessionQueue();
      refreshScene();
    }

    function startOver() {
      stopTimer(true);
      hideTimeOverlay();
      stopTableFlash();
      state.hand = [];
      state.board = [];
      state.deck = [];
      state.config.spotType = "";
      state.config.position = "";
      state.config.role = "";
      state.config.stacks = "";
      state.session.active = false;
      state.session.index = 0;
      state.stage = "start";
      renderConfigSelections();
      renderSessionQueue();
      refreshScene();
    }

    function goBackStreet() {
      hideTimeOverlay();
      stopTableFlash();

      if (state.stage === "done") {
        state.stage = "river";
        refreshScene();
        startTimerForStreet();
        return;
      }

      if (state.stage === "river") {
        state.board = state.board.slice(0, 4);
        state.stage = "turn";
        refreshScene();
        startTimerForStreet();
        return;
      }

      if (state.stage === "turn") {
        state.board = state.board.slice(0, 3);
        state.stage = "flop";
        refreshScene();
        startTimerForStreet();
        return;
      }

      if (state.stage === "flop") {
        stopTimer(true);
        state.board = [];
        state.stage = "hand";
        refreshScene();
        return;
      }

      if (state.stage === "hand") {
        stopTimer(true);
        state.hand = [];
        state.board = [];
        state.deck = [];
        state.stage = "start";
        refreshScene();
      }
    }

    function enterFlop() {
      if (state.hand.length !== 2) return;
      if (state.mode === "replay") {
        const replayFlop = resolveReplayCards(
          [state.manual.flop1, state.manual.flop2, state.manual.flop3],
          ["flop1", "flop2", "flop3"],
          state.hand,
          "Flop"
        );
        if (!replayFlop) return;
        state.board = replayFlop;
      } else {
        resetDeck(state.hand);
        state.board = [dealCard(), dealCard(), dealCard()];
      }
      state.stage = "flop";
      refreshScene();
      startTimerForStreet();
    }

    function enterTurn() {
      if (state.board.length < 3) return;
      const flop = state.board.slice(0, 3);
      if (state.mode === "replay") {
        const replayTurn = resolveReplayCards(
          [state.manual.turn],
          ["turn"],
          [...state.hand, ...flop],
          "Turn"
        );
        if (!replayTurn) return;
        state.board = [...flop, replayTurn[0]];
      } else {
        resetDeck([...state.hand, ...flop]);
        state.board = [...flop, dealCard()];
      }
      state.stage = "turn";
      refreshScene();
      startTimerForStreet();
    }

    function enterRiver() {
      if (state.board.length < 4) return;
      const four = state.board.slice(0, 4);
      if (state.mode === "replay") {
        const replayRiver = resolveReplayCards(
          [state.manual.river],
          ["river"],
          [...state.hand, ...four],
          "River"
        );
        if (!replayRiver) return;
        state.board = [...four, replayRiver[0]];
      } else {
        resetDeck([...state.hand, ...four]);
        state.board = [...four, dealCard()];
      }
      state.stage = "river";
      refreshScene();
      startTimerForStreet();
    }

    function keepRiver() {
      state.stage = "done";
      stopTimer(true);
      hideTimeOverlay();
      stopTableFlash();
      refreshScene();
    }

    function setCountdownIdle() {
      els.countdown.textContent = "Time left: --:--";
    }

    function updateTimerPauseButton() {
      const onStreet = ["flop", "turn", "river"].includes(state.stage);
      const hasTimer = state.timerChoice !== "None" && state.timeLeft > 0;
      const canToggle = onStreet && hasTimer && (Boolean(state.timerId) || state.timerPaused);

      els.timerPauseBtn.disabled = !canToggle;
      els.timerPauseBtn.textContent = state.timerPaused ? "Resume Timer" : "Pause Timer";
    }

    function toggleTimerPause() {
      if (els.timerPauseBtn.disabled) return;

      if (state.timerPaused) {
        state.timerPaused = false;
        startTimerTickLoop();
      } else if (state.timerId) {
        clearInterval(state.timerId);
        state.timerId = null;
        state.timerPaused = true;
      }

      updateTimerPauseButton();
    }

    function ensureAudioContext() {
      if (audioContext) {
        if (audioContext.state === "suspended") {
          audioContext.resume().catch(() => {});
        }
        return;
      }
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return;
      try {
        audioContext = new Ctx();
        if (audioContext.state === "suspended") {
          audioContext.resume().catch(() => {});
        }
      } catch (_err) {
        audioContext = null;
      }
    }

    function playTickSound() {
      if (!audioContext) return;
      const t = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();

      osc.type = "square";
      osc.frequency.setValueAtTime(920, t);

      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.linearRampToValueAtTime(0.09, t + 0.005);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);

      osc.connect(gain);
      gain.connect(audioContext.destination);
      osc.start(t);
      osc.stop(t + 0.07);
    }

    function updateCountdown() {
      const safe = Math.max(0, state.timeLeft);
      const mm = String(Math.floor(safe / 60)).padStart(2, "0");
      const ss = String(safe % 60).padStart(2, "0");
      els.countdown.textContent = `Time left: ${mm}:${ss}`;
    }

    function startTimerTickLoop() {
      if (state.timerId) return;
      state.timerId = window.setInterval(() => {
        state.timeLeft -= 1;
        updateCountdown();

        if (state.timeLeft > 0 && state.timeLeft <= 5) {
          playTickSound();
        }

        if (state.timeLeft <= 0) {
          stopTimer(false);
          onTimeUp();
        } else {
          updateTimerPauseButton();
        }
      }, 1000);
    }

    function stopTimer(resetDisplay) {
      if (state.timerId) {
        clearInterval(state.timerId);
        state.timerId = null;
      }
      state.timerPaused = false;
      if (resetDisplay) {
        setCountdownIdle();
      }
      updateTimerPauseButton();
    }

    function startTimerForStreet() {
      hideTimeOverlay();
      stopTableFlash();
      stopTimer(false);

      const seconds = TIMER_MAP[state.timerChoice] || 0;
      if (!seconds) {
        setCountdownIdle();
        updateTimerPauseButton();
        return;
      }

      state.timeLeft = seconds;
      state.timerPaused = false;
      updateCountdown();
      startTimerTickLoop();
      updateTimerPauseButton();
    }

    function showTimeOverlay() {
      els.timeOverlay.classList.add("show");
    }

    function hideTimeOverlay() {
      els.timeOverlay.classList.remove("show");
    }

    function stopTableFlash() {
      if (state.flashId) {
        clearInterval(state.flashId);
        state.flashId = null;
      }
      els.table.classList.remove("flash");
    }

    function flashTable() {
      stopTableFlash();
      let count = 0;
      state.flashId = window.setInterval(() => {
        els.table.classList.toggle("flash");
        count += 1;
        if (count >= 6) {
          stopTableFlash();
        }
      }, 140);
    }

    function onTimeUp() {
      showTimeOverlay();
      flashTable();
    }

    function formatCard(code) {
      if (!code || code.length < 2) return "??";
      return `${code[0].toUpperCase()}${code[1].toLowerCase()}`;
    }

    function cardImageCandidates(code) {
      const rank = code[0].toUpperCase();
      const suit = code[1].toLowerCase();
      const rankVariants = [rank, rank.toLowerCase()];
      const suitVariants = [suit, suit.toUpperCase()];
      if (rank === "T") rankVariants.push("10");

      const out = [];
      for (const prefix of CARD_PREFIXES) {
        for (const r of rankVariants) {
          for (const s of suitVariants) {
            out.push(`${prefix}${r}${s}.png`);
            out.push(`${prefix}${r}_${s}.png`);
          }
        }

        const rankWord = RANK_WORD[rank];
        const suitWord = SUIT_WORD[suit];
        if (rankWord && suitWord) {
          out.push(`${prefix}${rankWord}_of_${suitWord}.png`);
          out.push(`${prefix}${rankWord}_of_${suitWord}2.png`);
        }
      }
      return [...new Set(out)];
    }

    function backImageCandidates() {
      const names = ["back.png", "card_back.png", "cardback.png", "red_back.png", "blue_back.png", "backside.png"];
      const out = [];
      for (const prefix of CARD_PREFIXES) {
        for (const n of names) {
          out.push(`${prefix}${n}`);
        }
      }
      return out;
    }

    function buildGeneratedBackDataUri() {
      const width = 140;
      const height = 200;
      const cell = 20;
      let grid = "";

      for (let y = 0; y < height; y += cell) {
        for (let x = 0; x < width; x += cell) {
          const isOrange = ((x / cell) + (y / cell)) % 2 === 0;
          const fill = isOrange ? "#c85f00" : "#ffffff";
          grid += `<rect x="${x}" y="${y}" width="${cell}" height="${cell}" fill="${fill}"/>`;
        }
      }

      const svg =
        `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">` +
        `<rect x="0" y="0" width="${width}" height="${height}" fill="#ffffff"/>` +
        grid +
        `<rect x="2" y="2" width="${width - 4}" height="${height - 4}" fill="none" stroke="#000000" stroke-width="4"/>` +
        `</svg>`;

      return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
    }

    function attachImageWithFallback(img, fallbackEl, candidates) {
      let idx = 0;

      function tryNext() {
        if (idx >= candidates.length) {
          img.style.display = "none";
          fallbackEl.style.display = "flex";
          return;
        }
        img.src = candidates[idx];
        idx += 1;
      }

      img.addEventListener("load", () => {
        fallbackEl.style.display = "none";
        img.style.display = "block";
      });

      img.addEventListener("error", tryNext);
      tryNext();
    }

    function createCardElement(cardCode, isBack) {
      const shell = document.createElement("div");
      shell.className = "card-shell";

      const img = document.createElement("img");
      img.className = "card";
      img.alt = isBack ? "Card back" : `Card ${formatCard(cardCode)}`;

      const fallback = document.createElement("div");
      fallback.className = "card-fallback";
      fallback.textContent = isBack ? "BACK" : formatCard(cardCode);

      shell.appendChild(img);
      shell.appendChild(fallback);

      if (isBack && EMBEDDED_CARDS.back) {
        img.src = EMBEDDED_CARDS.back;
        fallback.style.display = "none";
        return shell;
      }

      if (isBack) {
        img.src = GENERATED_BACK_DATA_URI;
        fallback.style.display = "none";
        return shell;
      }

      if (!isBack && cardCode) {
        const key = formatCard(cardCode);
        if (EMBEDDED_CARDS[key]) {
          img.src = EMBEDDED_CARDS[key];
          fallback.style.display = "none";
          return shell;
        }
      }

      const candidates = isBack ? backImageCandidates() : cardImageCandidates(cardCode);
      attachImageWithFallback(img, fallback, candidates);
      return shell;
    }

    function renderBoard() {
      els.boardCards.innerHTML = "";
      if (!state.board.length) {
        const empty = document.createElement("div");
        empty.className = "empty-board";
        empty.textContent = "No board yet";
        els.boardCards.appendChild(empty);
        return;
      }

      state.board.forEach((card) => {
        els.boardCards.appendChild(createCardElement(card, false));
      });
    }

    function renderHand() {
      els.handCards.innerHTML = "";
      if (!state.hand.length) {
        els.handCards.appendChild(createCardElement(null, true));
        els.handCards.appendChild(createCardElement(null, true));
        return;
      }

      state.hand.forEach((card) => {
        els.handCards.appendChild(createCardElement(card, false));
      });
    }

    function setControls(buttons) {
      els.controls.innerHTML = "";
      buttons.forEach(({ text, primary, onClick }) => {
        const btn = document.createElement("button");
        btn.textContent = text;
        if (primary) btn.classList.add("primary");
        btn.addEventListener("click", () => {
          ensureAudioContext();
          onClick();
        });
        els.controls.appendChild(btn);
      });

      if (state.stage !== "start") {
        const backBtn = document.createElement("button");
        backBtn.textContent = "Go Back a Street";
        backBtn.addEventListener("click", () => {
          ensureAudioContext();
          goBackStreet();
        });
        els.controls.appendChild(backBtn);

        const resetBtn = document.createElement("button");
        resetBtn.textContent = "Start Over";
        resetBtn.addEventListener("click", startOver);
        els.controls.appendChild(resetBtn);
      }
    }

    function refreshScene() {
      renderBoard();
      renderHand();

      if (state.stage === "start") {
        els.startSplash.style.display = "block";
        setControls([{ text: "Deal", primary: true, onClick: dealHand }]);
        updateTimerPauseButton();
        renderConfigSelections();
        return;
      }

      els.startSplash.style.display = "none";

      if (state.stage === "hand") {
        setControls([
          { text: "Deal Flop", primary: true, onClick: enterFlop },
          { text: state.mode === "replay" ? "Edit Hand" : "New Hand", primary: false, onClick: dealHand }
        ]);
        updateTimerPauseButton();
        renderConfigSelections();
        return;
      }

      if (state.stage === "flop") {
        setControls([
          { text: "Deal Turn", primary: true, onClick: enterTurn },
          { text: state.mode === "replay" ? "Edit Flop" : "New Flop", primary: false, onClick: enterFlop }
        ]);
        updateTimerPauseButton();
        renderConfigSelections();
        return;
      }

      if (state.stage === "turn") {
        setControls([
          { text: "Deal River", primary: true, onClick: enterRiver },
          { text: state.mode === "replay" ? "Edit Turn" : "New Turn", primary: false, onClick: enterTurn }
        ]);
        updateTimerPauseButton();
        renderConfigSelections();
        return;
      }

      if (state.stage === "river") {
        setControls([
          { text: "Deal", primary: true, onClick: keepRiver },
          { text: state.mode === "replay" ? "Edit River" : "New River", primary: false, onClick: enterRiver }
        ]);
        updateTimerPauseButton();
        renderConfigSelections();
        return;
      }

      if (state.stage === "done") {
        setControls([
          { text: "Deal", primary: true, onClick: dealHand },
          { text: state.mode === "replay" ? "Edit River" : "New River", primary: false, onClick: enterRiver }
        ]);
      }

      updateTimerPauseButton();
      renderConfigSelections();
    }

    init();
  </script>
</body>
</html>
